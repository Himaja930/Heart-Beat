/*Project2: Madala,Himaja*/
#include <csim.h>
#include <stdio.h>


/*define CONSTANT*/
#define SIMTIME 1000.0
#define NUM_NODES 5l
#define TIME_OUT 2.0
#define PROCESS_TIME 0.2
#define TRANS_TIME 0.1
#define REQUEST 1L
#define REPLY 2L
#define INTER_ARR_TIME 5.0

typedef struct msg *msg_h;
struct msg {
    long type;
    long from;
    long to;
    TIME start_time;
    msg_h link;
    long count;
};

msg_h msg_queue;

struct nde {
    FACILITY cpu;
    MBOX mbox;
};

struct nde node[NUM_NODES];
FACILITY network[NUM_NODES][NUM_NODES];
TABLE resp_tm;

void init();
void proc();
void send_msg();
void form_reply();
void return_msg();
void decode_msg();
msg_h new_msg();
void count_msg();


long successful_transmissions, failed_transmissions;
long rtt;
long total_transmissions;
double loss_prob_threshold = 0.3;
long num_gen_mes_node1, num_gen_mes_node2, num_gen_mes_node3;
long num_gen_mes_node4, num_gen_mes_node0;

void sim(){
    printf( "Enter a loss probability threshold\n:");
    scanf("%lf", &loss_prob_threshold);
    printf( "You entered loss proability threshold: %lf\n", loss_prob_threshold);

    create("sim");
    init();
    hold(SIMTIME);


    printf("Statistics of loss probability: %lf\n", loss_prob_threshold);
    printf("Average number of successful transmissions %.2f\n", successful_transmissions/(float)total_transmissions);
    printf("Average number of failed transmissions %.2f\n", failed_transmissions/(float)total_transmissions);

    printf("%ld packets are generated by Node 0\n", num_gen_mes_node0);
    printf("%ld packets are generated by Node 1\n", num_gen_mes_node1);
    printf("%ld packets are generated by Node 2\n", num_gen_mes_node2);
    printf("%ld packets are generated by Node 3\n", num_gen_mes_node3);
    printf("%ld packets are generated by Node 4\n", num_gen_mes_node4);
}

void init(){
    long i, j;
    char str[24];

    max_facilities(NUM_NODES * NUM_NODES + NUM_NODES);
    max_servers(NUM_NODES * NUM_NODES + NUM_NODES);
    max_mailboxes(NUM_NODES);
    max_events(2 * NUM_NODES * NUM_NODES);
    resp_tm = table("msg rsp tm");
    msg_queue = NIL;

    for(i = 0; i < NUM_NODES; i++){
        sprintf(str, "cpu.%d", i);
        node[i].cpu = facility(str);
        sprintf(str, "input.%d", i);
        node[i].mbox = mailbox(str);
    }

    for(i = 0; i < NUM_NODES; i++){
        for(j = 0; j < NUM_NODES; j++){
            sprintf(str, "nt%d.%d", i, j);
            network[i][j] = facility(str);
        }
    }

    for(i = 0; i < NUM_NODES; i++){
        proc(i);
    }
        
}

void proc(long n){
    msg_h m;
    long s, t;  
    /* every node start to send a packet when its process is initiated*/
    create("proc");
    hold(exponential(INTER_ARR_TIME));
    m = new_msg(n);
    m->count = 1;
    printf("node.%ld sends a HELLO-%ld to node.%ld in %6.3f seconds\n", m->from, m->count, m->to, m->start_time);
    send_msg(m);     
    count_msg("gen msg", m);
  
    while(clock < SIMTIME){
        
        s = timed_receive(node[n].mbox, (long *)&m, TIME_OUT);
        switch(s){
            case TIMED_OUT:
                /* if the sender does not receive ack packet after sending the same packets two times --> it's failed, generate a new packet */
                if (m->count >= 2.0) {
                    hold(exponential(INTER_ARR_TIME));
                    m = new_msg(n);
                    m->count = 1;
                    printf("node.%ld sends a HELLO-%ld to node.%ld in %6.3f seconds\n", m->from, m->count, m->to, clock);
                    send_msg(m);     
                    count_msg("gen msg", m);
                    failed_transmissions += 1;
                    total_transmissions += 1;
                } else
                {                  
                    rtt += 2;
                    m->count += 1.0;
                    printf("node.%ld re-sends a HELLO-%ld to node.%ld in %6.3f seconds\n", m->from, m->count, m->to, clock);
                    send_msg(m);
                }
                
                break;
            case EVENT_OCCURRED:
                t = m->type;
                switch(t){
                case REQUEST:
                    /* it would take 0.2 seconds */
                    form_reply(m);
                    double loss_probability = uniform(0.0, 1.0);
                    if(loss_probability > loss_prob_threshold ){ 
                        printf("node.%ld replies a HELLO_ACK-%ld to node.%ld at %6.3f seconds\n", m->from, m->count, m->to, clock); 
                        send_msg(m);
                    }                        
                    
                    break;
                case REPLY:
                    record(clock - m->start_time, resp_tm);
                    return_msg(m);
                    successful_transmissions += 1;
                    rtt += 0.4;
                    total_transmissions += 1;
                    printf("node.%ld receives a HELLO_ACK-%ld from node.%ld at %6.3f seconds\n", m->to, m->count, m->from, clock);
                    break;
                default:
                    printf("Unexpected type");
                    break;
                }
                break;
        } 
    }
}

void count_msg(char *str, msg_h m){
    long node_num = m->from;
    switch (node_num)
    {
        case 0:
            num_gen_mes_node0 += 1;
            break;
        case 1:
            num_gen_mes_node1 += 1;
            break;
        case 2:
            num_gen_mes_node2 += 1;
            break;
        case 3:
            num_gen_mes_node3 += 1;
            break;
        case 4:
            num_gen_mes_node4 += 1;
            break;
    
        default:
            break;
    }
}


void send_msg(msg_h m){
    long from, to;
    from = m->from;
    to = m->to;

    reserve(network[from][to]);
    hold(TRANS_TIME);
    send(node[to].mbox, (long)m);
    release(network[from][to]);
}


msg_h new_msg(long from){
    msg_h m;
    long i;
    
    if(msg_queue == NIL){
        m = (msg_h)do_malloc(sizeof(struct msg));
    } else {
        m = msg_queue;
        msg_queue = msg_queue->link;
    }

    do {
        i = random(0L, NUM_NODES - 1);
    } while (i == from);

    m->to = i;
    m->from = from;
    m->type = REQUEST;
    m->start_time = clock;
    return m;
}


void return_msg(msg_h m){
    m->link = msg_queue;
    msg_queue = m;
}

void form_reply(msg_h m){
    long from, to;
    from = m->from;
    to = m->to;
    m->from = to;
    m->to = from;
    m->type = REPLY;
    /* Add local processing time for 0.2 seconds*/
    use(node[to].cpu, PROCESS_TIME);
}
